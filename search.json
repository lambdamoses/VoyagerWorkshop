[{"path":"https://lambdamoses.github.io/VoaygerWorkshop/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2020 Sean Davis Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/articles/workshop.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Exploratory spatial data analysis with Voyager","text":"Introduction slides available . rendered version workshop available . following R packages used workshop, CRAN Bioconductor. Bioconductor 3.17 used workshop presented Bioc2023.","code":"library(SpatialFeatureExperiment) library(SingleCellExperiment) library(Voyager) library(SFEData) library(scran) library(scater) library(ggplot2) library(rjson) library(Matrix) library(sf) library(scales) library(patchwork) library(BiocParallel) library(tibble) library(tidyr) library(scico) library(pheatmap) library(BiocNeighbors) library(BiocSingular) library(bluster) theme_set(theme_bw())"},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/articles/workshop.html","id":"spatialfeatureexperiment","dir":"Articles","previous_headings":"Introduction","what":"SpatialFeatureExperiment","title":"Exploratory spatial data analysis with Voyager","text":"SpatialFeatureExperiment (SFE) new S4 class built top SpatialExperiment (SPE). SFE incorporates geometries geometric operations sf package. Examples supported geometries Visium spots represented polygons corresponding size, cell nuclei segmentation polygons, tissue boundary polygons, pathologist annotation histological regions, transcript spots genes. Using sf, SpatialFeatureExperiment leverages GEOS C++ library underlying sf geometry operations, including algorithms determining whether geometries intersect, finding intersection geometries, buffering geometries margins, etc. schematic SFE object shown :  list SFE features extend SPE object: colGeometries sf data frames associated entities correspond columns gene count matrix, Visium spots cells. geometries sf data frames can Visium spot centroids, Visium spot polygons, datasets single cell resolution, cell nuclei segmentations. Multiple colGeometries can stored SFE object, one cell segmentation another nuclei segmentation. can non-spatial, attribute columns colGeometry rather colData, sf class allows users specify attributes relate geometries, “constant”, “aggregate”, “identity”. See agr argument st_sf documentation. colGraphs spatial neighborhood graphs cells spots. graphs class listw (spdep package), colPairs SingleCellExperiment used conversion necessary use numerous spatial dependency functions spdep, Moran’s , Geary’s C, Getis-Ord Gi*, LOSH, etc. Conversion also needed classical spatial statistics packages spatialreg adespatial. rowGeometries similar colGeometries, support entities correspond rows gene count matrix, genes. potential use case store transcript spots gene smFISH situ sequencing based datasets. rowGraphs similar colGraphs. potential use case may spatial colocalization transcripts different genes. annotGeometries sf data frames associated dataset directly gene count matrix, tissue boundaries, histological regions, cell nuclei segmentation Visium datasets, etc. geometries stored object facilitate plotting using sf operations find number nuclei Visium spot histological regions Visium spot intersects. Unlike colGeometries rowGeometries, number rows sf data frames annotGeometries constrained dimension gene count matrix can arbitrary. annotGraphs similar colGraphs rowGraphs, entities directly associated gene count matrix, spatial neighborhood graphs nuclei Visium datasets, objects like myofibers. graphs relevant spdep analyses attributes geometries spatial autocorrelation morphological metrics myofibers nuclei. geometry operations sf, attributes results analyses attributes (e.g. spatial regions defined attributes) may related back gene expression. localResults similar reducedDims SingleCellExperiment, stores results univariate bivariate local spatial analysis results, localmoran, Getis-Ord Gi*, local spatial heteroscedasticity (LOSH). Unlike reducedDims, type results (type type analysis Getis-Ord Gi*), feature (e.g. gene) pair features analysis performed results. local spatial analyses can also performed attributes colGeometries annotGeometries addition gene expression colData. Results multivariate spatial analysis MULTISPATI PCA can stored reducedDims.","code":""},{"path":[]},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/articles/workshop.html","id":"x-visium","dir":"Articles","previous_headings":"Introduction","what":"10X Visium","title":"Exploratory spatial data analysis with Voyager","text":"Visium 10X Genomics currently popular spatial transcriptomics technology, workshop uses Visium dataset.  Visium, capture sequences spot barcode, unique molecule identifier (UMI), polyT capture poly-adenylated mRNAs printed hexagonal array glass slide. spot barcode known location, spots 55 \\(\\mu m\\) diameter 100 \\(\\mu m\\) apart center center. spots much larger types cells, Visium single cell resolution. Tissue mounted 4 capture areas slide, capture area 4992 spots. spots capture transcripts tissue, reverse transcribed, amplified, sequenced.  Space Ranger official software align sequencing reads genome quantify UMIs spot gene. Spatial Ranger also takes histology image capture area, determines spots tissue. user can also manually determine spots tissue Loupe Browser.","code":""},{"path":[]},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/articles/workshop.html","id":"create-an-sfe-object","dir":"Articles","previous_headings":"Part 1: The SFE class","what":"Create an SFE object","title":"Exploratory spatial data analysis with Voyager","text":"10x Genomics Space Ranger output Visium experiment can read similar manner SpatialExperiment; SpatialFeatureExperiment SFE object spotPoly column geometry spot polygons. filtered matrix (.e. spots tissue) read , column graph called visium also present spatial neighborhood graph Visium spots tissue. graph computed spots read regardless whether tissue. results tissue capture outs directory sample directory. Inside outs directory, directories may present: raw_reature_bc_matrix unfiltered gene count matrix, filtered_feature_bc_matrix gene count matrix spots tissue, spatial spatial information. matrix directories contain matrices MTX format sparse matrices. Space Ranger also outputs matrices h5 files, read R similar way MTX. Inside matrix directory: Inside spatial directory: tissue_lowres_image.png low resolution image tissue. Visium datasets files . barcode_fluorescence_intensity.csv file present datasets fluorescent imaging rather bright field H&E. Space Ranger output includes gene count matrix, spot coordinates, spot diameter. Space Ranger output include nuclei segmentation pathologist annotation histological regions. Extra image processing, ImageJ QuPath, required geometries. See vignette creating SFE objects scratch spatial trancriptomics technologies.","code":"dir <- system.file(\"extdata\", package = \"SpatialFeatureExperiment\") sample_ids <- c(\"sample01\", \"sample02\") (samples <- file.path(dir, sample_ids)) #> [1] \"/usr/local/lib/R/site-library/SpatialFeatureExperiment/extdata/sample01\" #> [2] \"/usr/local/lib/R/site-library/SpatialFeatureExperiment/extdata/sample02\" list.files(file.path(samples[1], \"outs\")) #> [1] \"filtered_feature_bc_matrix\" \"spatial\" list.files(file.path(samples[1], \"outs\", \"filtered_feature_bc_matrix\")) #> [1] \"barcodes.tsv\" \"features.tsv\" \"matrix.mtx\" list.files(file.path(samples[1], \"outs\", \"spatial\")) #> [1] \"aligned_fiducials.jpg\"              \"barcode_fluorescence_intensity.csv\" #> [3] \"detected_tissue_image.jpg\"          \"scalefactors_json.json\"             #> [5] \"spatial_enrichment.csv\"             \"tissue_hires_image.png\"             #> [7] \"tissue_lowres_image.png\"            \"tissue_positions.csv\" (sfe3 <- read10xVisiumSFE(samples, sample_id = sample_ids, type = \"sparse\",                            data = \"filtered\")) #> class: SpatialFeatureExperiment  #> dim: 5 25  #> metadata(0): #> assays(1): counts #> rownames(5): ENSG00000014257 ENSG00000142515 ENSG00000263639 #>   ENSG00000163810 ENSG00000149591 #> rowData names(14): symbol Feature.Type ... #>   Median.Normalized.Average.Counts_sample02 #>   Barcodes.Detected.per.Feature_sample02 #> colnames(25): GTGGCGTGCACCAGAG-1 GGTCCCATAACATAGA-1 ... #>   TGCAATTTGGGCACGG-1 ATGCCAATCGCTCTGC-1 #> colData names(10): in_tissue array_row ... channel3_mean channel3_stdev #> reducedDimNames(0): #> mainExpName: NULL #> altExpNames(0): #> spatialCoords names(2) : pxl_col_in_fullres pxl_row_in_fullres #> imgData names(4): sample_id image_id data scaleFactor #>  #> unit: full_res_image_pixel #> Geometries: #> colGeometries: spotPoly (POLYGON)  #>  #> Graphs: #> sample01: col: visium #> sample02: col: visium"},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/articles/workshop.html","id":"operations-of-sfe-objects","dir":"Articles","previous_headings":"Part 1: The SFE class","what":"Operations of SFE objects","title":"Exploratory spatial data analysis with Voyager","text":"User interfaces get set geometries spatial graphs emulate reducedDims row/colPairs SingleCellExperiment. Column row geometries also emulate reducedDims internal implementation, annotation geometries spatial graphs differ. Operations SFE objects demonstrated small toy dataset (may need answer prompt R console downloading dataset):","code":"(sfe <- McKellarMuscleData(dataset = \"small\")) #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache #> class: SpatialFeatureExperiment  #> dim: 15123 77  #> metadata(0): #> assays(1): counts #> rownames(15123): ENSMUSG00000025902 ENSMUSG00000096126 ... #>   ENSMUSG00000064368 ENSMUSG00000064370 #> rowData names(6): Ensembl symbol ... vars cv2 #> colnames(77): AAATTACCTATCGATG AACATATCAACTGGTG ... TTCTTTGGTCGCGACG #>   TTGATGTGTAGTCCCG #> colData names(12): barcode col ... prop_mito in_tissue #> reducedDimNames(0): #> mainExpName: NULL #> altExpNames(0): #> spatialCoords names(2) : imageX imageY #> imgData names(1): sample_id #>  #> unit: full_res_image_pixels #> Geometries: #> colGeometries: spotPoly (POLYGON)  #> annotGeometries: tissueBoundary (POLYGON), myofiber_full (GEOMETRY), myofiber_simplified (GEOMETRY), nuclei (POLYGON), nuclei_centroid (POINT)  #>  #> Graphs: #> Vis5A:"},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/articles/workshop.html","id":"column-geometries","dir":"Articles","previous_headings":"Part 1: The SFE class > Operations of SFE objects","what":"Column geometries","title":"Exploratory spatial data analysis with Voyager","text":"Column geometries colGeometries geometries correspond columns gene count matrix, Visium spots cells datasets single cell resolution technology. SFE object can multiple column geometries. example, dataset single cell resolution, whole cell segmentation nuclei segmentation two different colGeometries. However, Visium, spot polygons colGeometry obviously relevant, though users can add geometries results geometric operations spot polygons. different geometries can get set names, “spotPoly” standard name Visium spot polygons.  see colGeometries present SFE object: shorthands specific column row geometries. example, spotPoly(sfe) equivalent colGeometry(sfe, \"spotPoly\") shown .","code":"# Get Visium spot polygons (spots <- colGeometry(sfe, \"spotPoly\")) #> Simple feature collection with 77 features and 1 field #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 5000 ymin: 13000 xmax: 7000 ymax: 15000 #> CRS:           NA #> First 10 features: #>                                        geometry sample_id #> AAATTACCTATCGATG POLYGON ((6472.186 13875.23...     Vis5A #> AACATATCAACTGGTG POLYGON ((5778.291 13635.43...     Vis5A #> AAGATTGGCGGAACGT POLYGON ((7000 13809.84, 69...     Vis5A #> AAGGGACAGATTCTGT POLYGON ((6749.535 13874.64...     Vis5A #> AATATCGAGGGTTCTC POLYGON ((5500.941 13636.03...     Vis5A #> AATGATGATACGCTAT POLYGON ((6612.42 14598.82,...     Vis5A #> AATGATGCGACTCCTG POLYGON ((5501.981 14118.62...     Vis5A #> AATTCATAAGGGATCT POLYGON ((6889.769 14598.22...     Vis5A #> ACGAGTACGGATGCCC POLYGON ((5084.397 13395.63...     Vis5A #> ACGCTAGTGATACACT POLYGON ((5639.096 13394.44...     Vis5A plot(st_geometry(spots)) # Set colGeometry colGeometry(sfe, \"spotPoly\") <- spots colGeometryNames(sfe) #> [1] \"spotPoly\" # Getter (spots <- spotPoly(sfe)) #> Simple feature collection with 77 features and 1 field #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 5000 ymin: 13000 xmax: 7000 ymax: 15000 #> CRS:           NA #> First 10 features: #>                                        geometry sample_id #> AAATTACCTATCGATG POLYGON ((6472.186 13875.23...     Vis5A #> AACATATCAACTGGTG POLYGON ((5778.291 13635.43...     Vis5A #> AAGATTGGCGGAACGT POLYGON ((7000 13809.84, 69...     Vis5A #> AAGGGACAGATTCTGT POLYGON ((6749.535 13874.64...     Vis5A #> AATATCGAGGGTTCTC POLYGON ((5500.941 13636.03...     Vis5A #> AATGATGATACGCTAT POLYGON ((6612.42 14598.82,...     Vis5A #> AATGATGCGACTCCTG POLYGON ((5501.981 14118.62...     Vis5A #> AATTCATAAGGGATCT POLYGON ((6889.769 14598.22...     Vis5A #> ACGAGTACGGATGCCC POLYGON ((5084.397 13395.63...     Vis5A #> ACGCTAGTGATACACT POLYGON ((5639.096 13394.44...     Vis5A # Setter spotPoly(sfe) <- spots"},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/articles/workshop.html","id":"annotation","dir":"Articles","previous_headings":"Part 1: The SFE class > Operations of SFE objects","what":"Annotation","title":"Exploratory spatial data analysis with Voyager","text":"Annotation geometries can get set annotGeometry(). column row geometries, number rows sf data frame (.e. number geometries data frame) constrained number rows columns gene count matrix respectively, just like rowData colData, row rowGeometry colGeometry sf data frame must correspond row column gene count matrix respectively. contrast, annotGeometry sf data frame can dimension, constrained dimension gene count matrix.  See annotGeometries present SFE object: shorthands specific annotation geometries. example, tissueBoundary(sfe) equivalent annotGeometry(sfe, \"tissueBoundary\"). cellSeg() (cell segmentation) nucSeg() (nuclei segmentation) first query colGeometries (single cell, single molecule technologies, equivalent colGeometry(sfe, \"cellSeg\") colGeometry(sfe, \"nucSeg\")), found, query annotGeometries (array capture microdissection technologies, equivalent annotGeometry(sfe, \"cellSeg\") annotGeometry(sfe, \"nucSeg\")).","code":"# Getter, by name or index (tb <- annotGeometry(sfe, \"tissueBoundary\")) #> Simple feature collection with 1 feature and 2 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 5094 ymin: 13000 xmax: 7000 ymax: 14969 #> CRS:           NA #>   ID                       geometry sample_id #> 7  7 POLYGON ((5094 13000, 5095 ...     Vis5A plot(st_geometry(tb)) # Setter, by name or index annotGeometry(sfe, \"tissueBoundary\") <- tb annotGeometryNames(sfe) #> [1] \"tissueBoundary\"      \"myofiber_full\"       \"myofiber_simplified\" #> [4] \"nuclei\"              \"nuclei_centroid\" # Getter (tb <- tissueBoundary(sfe)) #> Simple feature collection with 1 feature and 2 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 5094 ymin: 13000 xmax: 7000 ymax: 14969 #> CRS:           NA #>   ID                       geometry sample_id #> 7  7 POLYGON ((5094 13000, 5095 ...     Vis5A # Setter tissueBoundary(sfe) <- tb"},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/articles/workshop.html","id":"spatial-graphs","dir":"Articles","previous_headings":"Part 1: The SFE class > Operations of SFE objects","what":"Spatial graphs","title":"Exploratory spatial data analysis with Voyager","text":"spatial neighborhood graphs Visium spots stored colGraphs field, similar user interface colGeometries. SFE also wraps methods find spatial neighborhood graph implemented spdep package, triangulation used demonstration.  Visium, spatial neighborhood graph hexagonal grid can found known locations barcodes. One SFE object can multiple colGraphs.  graphs present SFE object? workshop works one sample, .e. tissue section, operations multiple samples discussed vignette SFE package.","code":"(g <- findSpatialNeighbors(sfe, MARGIN = 2, method = \"tri2nb\")) #> Characteristics of weights list object: #> Neighbour list object: #> Number of regions: 77  #> Number of nonzero links: 428  #> Percentage nonzero weights: 7.218755  #> Average number of links: 5.558442  #>  #> Weights style: W  #> Weights constants summary: #>    n   nn S0      S1       S2 #> W 77 5929 77 28.0096 309.4083 plot(g, coords = spatialCoords(sfe)) # Set graph by name colGraph(sfe, \"graph1\") <- g # Get graph by name (g <- colGraph(sfe, \"graph1\")) #> Characteristics of weights list object: #> Neighbour list object: #> Number of regions: 77  #> Number of nonzero links: 428  #> Percentage nonzero weights: 7.218755  #> Average number of links: 5.558442  #>  #> Weights style: W  #> Weights constants summary: #>    n   nn S0      S1       S2 #> W 77 5929 77 28.0096 309.4083 colGraph(sfe, \"visium\") <- findVisiumGraph(sfe) plot(colGraph(sfe, \"visium\"), coords = spatialCoords(sfe)) colGraphNames(sfe) #> [1] \"graph1\" \"visium\""},{"path":[]},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/articles/workshop.html","id":"dataset","dir":"Articles","previous_headings":"Part 2: Voyager ESDA","what":"Dataset","title":"Exploratory spatial data analysis with Voyager","text":"dataset used vignette paper Large-scale integration single-cell transcriptomic data captures transitional progenitor states mouse skeletal muscle regeneration (McKellar et al. 2021). Notexin injected tibialis anterior muscle mice induce injury, healing muscle collected 2, 5, 7 days post injury Visium analysis. dataset vignette timepoint day 2. vignette starts SpatialFeatureExperiment (SFE) object. gene count matrix directly downloaded GEO. 4992 spots, whether tissue , included. H&E image used nuclei myofiber segmentation. subset nuclei randomly selected regions 3 timepoints manually annotated train StarDist model segment rest nuclei, myofibers manually segmented. tissue boundary found thresholding OpenCV, small polygons removed likely debris. Spot polygons constructed spot centroid coordinates diameter Space Ranger output. in_tissue column colData indicates spot polygons intersect tissue polygons, based st_intersects(). Tissue boundary, nuclei, myofiber, Visium spot polygons stored sf data frames SFE object. See vignette SpatialFeatureExperiment details structure SFE object. SFE object dataset provided SFEData package; begin downloading data loading R. H&E image section: image can added SFE object plotted behind geometries, needs flipped align spots origin top left image bottom left geometries.","code":"(sfe <- McKellarMuscleData(\"full\")) #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache #> class: SpatialFeatureExperiment  #> dim: 15123 4992  #> metadata(0): #> assays(1): counts #> rownames(15123): ENSMUSG00000025902 ENSMUSG00000096126 ... #>   ENSMUSG00000064368 ENSMUSG00000064370 #> rowData names(6): Ensembl symbol ... vars cv2 #> colnames(4992): AAACAACGAATAGTTC AAACAAGTATCTCCCA ... TTGTTTGTATTACACG #>   TTGTTTGTGTAAATTC #> colData names(12): barcode col ... prop_mito in_tissue #> reducedDimNames(0): #> mainExpName: NULL #> altExpNames(0): #> spatialCoords names(2) : imageX imageY #> imgData names(1): sample_id #>  #> unit: full_res_image_pixels #> Geometries: #> colGeometries: spotPoly (POLYGON)  #> annotGeometries: tissueBoundary (POLYGON), myofiber_full (POLYGON), myofiber_simplified (POLYGON), nuclei (POLYGON), nuclei_centroid (POINT)  #>  #> Graphs: #> Vis5A: sfe <- addImg(sfe, file = \"tissue_lowres_5a.jpeg\", sample_id = \"Vis5A\",                image_id = \"lowres\",                scale_fct = 1024/22208) sfe <- mirrorImg(sfe, sample_id = \"Vis5A\", image_id = \"lowres\")"},{"path":[]},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/articles/workshop.html","id":"spots-in-tissue","dir":"Articles","previous_headings":"Part 2: Voyager ESDA > Exploratory data analysis","what":"Spots in tissue","title":"Exploratory spatial data analysis with Voyager","text":"example dataset Visium spots whether tissue , spots intersect tissue used analyses. Total UMI counts (nCounts), number genes detected per spot (nGenes), proportion mitochondrially encoded counts (prop_mito) precomputed colData(sfe). plotSpatialFeature() function can used visualize various attributes space: expression gene, colData values, geometry attributes colGeometry annotGeometry. Visium spots plotted polygons reflecting actual size relative tissue, rather points, case packages plot Visium data. plotting geometries performed hood geom_sf. tissue boundary found thresholding H&E image removing small polygons likely debris. in_tissue column colData(sfe) indicates Visium spot polygon intersects tissue polygon; can found SpatialFeatureExperiment::annotPred(). demonstrate use scran (Lun, Bach, Marioni 2016) normalization , although note necessarily best approach normalizing spatial transcriptomics data. problem normalize spatial transcriptomics data non-trivial , nCounts plot space shows , spatial autocorrelation evident. Furthermore, Visium, reverse transcription occurs situ spots, PCR amplification occurs cDNA dissociated spots. Artifacts may subsequently introduced amplification step, associated spatial origin. Spatial artifacts may arise diffusion transcripts tissue permeablization. However, given total counts seem correspond histological regions, total counts may biological component hence treated technical artifact normalized away scRNA-seq data normalization methods. words, issue normalization spatial transcriptomics data, Visium particular, complex currently unsolved. Myofiber nuclei segmentation polygons available dataset annotGeometries field. Myofibers manually segmented, nuclei segmented StarDist trained manually segmented subset.","code":"names(colData(sfe)) #>  [1] \"barcode\"   \"col\"       \"row\"       \"x\"         \"y\"         \"dia\"       #>  [7] \"tissue\"    \"sample_id\" \"nCounts\"   \"nGenes\"    \"prop_mito\" \"in_tissue\" sfe_tissue <- sfe[,colData(sfe)$in_tissue] sfe_tissue <- sfe_tissue[rowSums(counts(sfe_tissue)) > 0,] #clusters <- quickCluster(sfe_tissue) #sfe_tissue <- computeSumFactors(sfe_tissue, clusters=clusters) #sfe_tissue <- sfe_tissue[, sizeFactors(sfe_tissue) > 0] sfe_tissue <- logNormCounts(sfe_tissue) annotGeometryNames(sfe_tissue) #> [1] \"tissueBoundary\"      \"myofiber_full\"       \"myofiber_simplified\" #> [4] \"nuclei\"              \"nuclei_centroid\""},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/articles/workshop.html","id":"from-myofibers-and-nuclei-to-visium-spots","dir":"Articles","previous_headings":"Part 2: Voyager ESDA > Exploratory data analysis > Spots in tissue","what":"From myofibers and nuclei to Visium spots","title":"Exploratory spatial data analysis with Voyager","text":"plotSpatialFeature() function can also used plot attributes geometries, .e. non-geometry columns sf data frames rowGeometries, colGeometries, annotGeometries fields SFE object. myofiber polygons annotGeometries can plotted shown , colored cross section area observed tissue section. aes_use argument set color rather fill (default polygons) plot Visium spot outlines make myofiber polygons visible. fill argument set NA make Visium spots look hollow, size argument controls thickness outlines. annot_aes argument specifies column annotGeometry use specify values aesthstic, just like aes ggplot2 (aes_string precise, since tidyeval used ). annot_fixed argument (used ) can set fixed size, alpha, color, etc. annotGeometry.  larger myofibers seem fewer total counts, possibly larger size myofibers dilutes transcripts. hints need normalization procedure. SpatialFeatureExperiment, can find number myofibers nuclei intersect Visium spot. predicate can anything implemented sf, example, number nuclei fully covered Visium spot can also found. default predicate st_intersects().  one--one mapping Visium spots myofibers. However, can relate attributes myofibers gene expression detected Visium spots. One way summarize attributes myofibers intersect (choose another better predicate implemented sf) spot, calculate mean, median, sum. can done annotSummary() function SpatialFeatureExperiment. default predicate st_intersects(), default summary function mean().  reveals relationship mean area myofibers intersecting Visium spot aspects spots, total counts gene expression. NAs (gray) designate spots intersecting myofibers, e.g. inflammatory region. nGenes vs. nCounts plot standard QC plot scRNA-seq, see two mysterious branches two clusters nGenes vs. nCounts plot proportion mitochondrial counts vs. nCounts plot. two branches clusters seem related myofiber size.","code":"plotSpatialFeature(sfe_tissue, features = \"nCounts\",                     colGeometryName = \"spotPoly\",                    annotGeometryName = \"myofiber_simplified\",                     aes_use = \"color\", linewidth = 0.5, fill = NA,                    annot_aes = list(fill = \"area\")) colData(sfe_tissue)$n_myofibers <-    annotNPred(sfe_tissue, colGeometryName = \"spotPoly\",              annotGeometryName = \"myofiber_simplified\") plotSpatialFeature(sfe_tissue, features = \"n_myofibers\",                     colGeometryName = \"spotPoly\", image = \"lowres\", color = \"black\",                    linewidth = 0.1) colData(sfe_tissue)$mean_myofiber_area <-    annotSummary(sfe_tissue, \"spotPoly\", \"myofiber_simplified\",                 annotColNames = \"area\")[,1] # it always returns a data frame # The gray spots don't intersect any myofiber plotSpatialFeature(sfe_tissue, \"mean_myofiber_area\", \"spotPoly\", image = \"lowres\",                     color = \"black\", linewidth = 0.1) plotColData(sfe_tissue, x = \"nCounts\", y = \"nGenes\", colour_by = \"mean_myofiber_area\") plotColData(sfe_tissue, x = \"nCounts\", y = \"prop_mito\", colour_by = \"mean_myofiber_area\")"},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/articles/workshop.html","id":"exercises","dir":"Articles","previous_headings":"","what":"Exploratory spatial data analysis with Voyager","title":"Exploratory spatial data analysis with Voyager","text":"Use annotNPred() function find number nuclei intersecting Visium spot. nuclei segmentation polygons annotGeometry called “nuclei”. Color Visium spots number nuclei. histological region tends nuclei per Visium spot? number nuclei per spot correlate nCounts?","code":""},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/articles/workshop.html","id":"plot-gene-expression-in-space","dir":"Articles","previous_headings":"Part 2: Voyager ESDA > Exploratory data analysis > Spots in tissue","what":"Plot gene expression in space","title":"Exploratory spatial data analysis with Voyager","text":"Marker genes: Myh7 (Type , slow twitch, aerobic), Myh2 (Type IIa, fast twitch, somewhat aerobic), Myh4 (Type IIb, fast twitch, anareobic), Myh1 (Type IIx, fast twitch, anaerobic), protocol (Wang, Yue, Kuang 2017) first examine Type myofibers. fast twitch muscle, don’t expect many slow twitch Type myofibers. Row names sfe_tissue Ensembl IDs order avoid ambiguity sometimes multiple Ensembl IDs gene symbol genes aliases. However, gene symbols shorter human readable Ensembl IDs, better suited display plots. plotSpatialFeature() function functions Voyager, even row names recorded Ensembl IDs, features argument can take gene symbols column rowData(sfe) gene symbols supplied swap_rownames argument. function Voyager queries genes swap_rownames argument.","code":"markers <- c(I = \"Myh7\", IIa = \"Myh2\", IIb = \"Myh4\", IIx = \"Myh1\") plotSpatialFeature(sfe_tissue, \"Myh2\", \"spotPoly\",                    annotGeometryName = \"myofiber_simplified\",                     annot_aes = list(fill = \"area\"), swap_rownames = \"symbol\",                     exprs_values = \"logcounts\", aes_use = \"color\", linewidth = 0.5,                    fill = NA)"},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/articles/workshop.html","id":"exercises-1","dir":"Articles","previous_headings":"","what":"Exploratory spatial data analysis with Voyager","title":"Exploratory spatial data analysis with Voyager","text":"exprs_values argument specifies assay use, default “logcounts”, .e. log normalized data. default may may suitable practice given total UMI counts may biological relevance spatial data. Plot one marker genes , “counts” assay. Look documentation plotSpatialFeature(). Try plotting Visium spots filled circles partially transparent.","code":""},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/articles/workshop.html","id":"spatial-neighborhood-graphs","dir":"Articles","previous_headings":"Part 2: Voyager ESDA","what":"Spatial neighborhood graphs","title":"Exploratory spatial data analysis with Voyager","text":"spatial neighborhood graph required compute spatial dependency metrics Moran’s Geary’s C. SpatialFeatureExperiment package wraps methods spdep find spatial neighborhood graphs, stored within SFE object (see spdep documentation gabrielneigh(), knearneigh(), poly2nb(), tri2nb()). Voyager package uses graphs spatial dependency analyses, based spdep first version, methods geospatial packages, also use spatial neighborhood graphs, may added later. Visium, spots hexagonal grid, spatial neighborhood graph straightforward. However, spatial technologies single cell resolution, e.g. MERFISH, different methods can used find spatial neighborhood graph. example, method “poly2nb” used myofibers, identifies myofiber polygons physically touch . zero.policy = TRUE allow singletons, .e. nodes without neighbors graph; inflamed region, singletons. yet benchmarked spatial neighborhood construction methods determine “best” different technologies; particular method used demonstration purposes may best practice: plotColGraph() function plots graph space associated colGeometry, along geometry interest.  Similarly, plotAnnotGraph() function plots graph associated annotGeometry, along geometry interest.  plotRowGraph yet since haven’t worked dataset spatial graphs related genes relevant, although SFE object supports row graphs.","code":"colGraph(sfe_tissue, \"visium\") <- findVisiumGraph(sfe_tissue) annotGraph(sfe_tissue, \"myofiber_poly2nb\") <-    findSpatialNeighbors(sfe_tissue, type = \"myofiber_simplified\", MARGIN = 3,                        method = \"poly2nb\", zero.policy = TRUE) plotColGraph(sfe_tissue, colGraphName = \"visium\", colGeometryName = \"spotPoly\") +     theme_void() plotAnnotGraph(sfe_tissue, annotGraphName = \"myofiber_poly2nb\",                 annotGeometryName = \"myofiber_simplified\") + theme_void()"},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/articles/workshop.html","id":"exploratory-spatial-data-analysis","dir":"Articles","previous_headings":"Part 2: Voyager ESDA","what":"Exploratory spatial data analysis","title":"Exploratory spatial data analysis with Voyager","text":"spatial autocorrelation metrics package can computed directly vector matrix rather SFE object. user interface emulates dimension reductions scater package (e.g. calculateUMAP() takes matrix SCE object returns matrix, runUMAP() takes SCE object adds results reducedDims field SCE object). calculate* functions take matrix SFE object directly return results (format results depends structure results), run* functions take SFE object add results object. addition, colData* functions compute metrics numeric variables colData. colGeometry* functions compute metrics numeric columns colGeometry. annotGeometry* functions compute metrics numeric columns annotGeometry.","code":""},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/articles/workshop.html","id":"univariate-global","dir":"Articles","previous_headings":"Part 2: Voyager ESDA","what":"Univariate global","title":"Exploratory spatial data analysis with Voyager","text":"Voyager supports many univariate global spatial autocorrelation implemented spdep ESDA: Moran’s Geary’s C, permutation testing Moran’s Geary’s C, Moran plot, correlograms. addition, beyond spdep, Voyager can cluster Moran plots correlograms. Plotting functions taking SFE objects implemented plot results ggplot2 customization options spdep plotting functions. functions calculateUnivariate() (can take data outside SFE objects), runUnivariate() (gene expression), colDataUnivariate(), colGeometryUnivariate(), annotGeometryUnivariate(), reducedDimUnivariate() compute univariate spatial statistics different fields SFE object, arguments except arguments specific field SFE object. argument type, indicates corresponding function names spdep, determines spatial statistics computed. univariate global methods Voyager listed : calling calculate*variate() run*variate(), type (2nd) argument takes string matches entry name column data frame returned listSFEMethods(). demonstrate spatial autocorrelation gene expression, top highly variable genes (HVGs) used. HVGs found scran method. global statistic yields one result entire dataset.","code":"listSFEMethods(variate = \"uni\", scope = \"global\") #>              name                                           description #> 1           moran                                             Moran's I #> 2           geary                                             Geary's C #> 3        moran.mc                    Moran's I with permutation testing #> 4        geary.mc                    Geary's C with permutation testing #> 5    sp.mantel.mc Mantel-Hubert spatial general cross product statistic #> 6      moran.test                                        Moran's I test #> 7      geary.test                                        Geary's C test #> 8    globalG.test                                         Global G test #> 9  sp.correlogram                                           Correlogram #> 10      variogram                                  Variogram with model #> 11  variogram_map                                         Variogram map dec <- modelGeneVar(sfe_tissue) hvgs <- getTopHVGs(dec, n = 50)"},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/articles/workshop.html","id":"morans-i","dir":"Articles","previous_headings":"Part 2: Voyager ESDA > Univariate global","what":"Moran’s I","title":"Exploratory spatial data analysis with Voyager","text":"reference, Pearson correlation defined \\[ \\rho_{X,Y} = \\frac{\\sum_{=1}^n\\sum_{j=1}^n (x_i - \\bar x)(y_i - \\bar y)}{\\sqrt{\\sum_{=1}^n (x_i - \\bar x)^2}\\sqrt{\\sum_{=1}^n (y_i - \\bar y)^2}}. \\] several ways quantify spatial autocorrelation, common Moran’s (Moran 1950): \\[ = \\frac{n}{\\sum_{=1}^n \\sum_{j=1}^n w_{ij}} \\frac{\\sum_{=1}^n \\sum_{j=1}^n w_{ij} (x_i - \\bar{x})(x_j - \\bar{x})}{\\sum_{=1}^n (x_i - \\bar{x})^2}, \\] \\(n\\) number spots locations, \\(\\) \\(j\\) different locations, spots Visium context, \\(x\\) \\(y\\) variables values location, \\(w_{ij}\\) spatial weight, can inversely proportional distance spots indicator whether two spots neighbors, subject various definitions neighborhood whether normalize number neighbors. spdep package uses neighborhood. Moran’s analogous Pearson correlation value location average value neighbors (identical, see (Lee 2001)). Just like Pearson correlation, Moran’s generally bound -1 1, positive value indicates positive spatial autocorrelation, .e. nearby values tend similar, negative value indicates negative spatial autocorrelation, .e. nearby values tend dissimilar. Upon visual inspection earlier workshop, total UMI counts per spot (nCounts) seem spatial autocorrelation. numeric columns colData(sfe), univariate methods can called colDataUnivariate(). compute Moran’s nCounts nGenes: colData, results added colFeatureData(sfe), features Moran’s calculated NA. column names featureData distinguishes different samples (’s one sample dataset), parsed plotting functions. first column Moran’s value, indicates moderate positive spatial autocorrelation nCounts nGenes. second column kurtosis data. Compute Moran’s attributes geometries: “area” area cross section myofiber seen tissue section “eccentricity” eccentricity ellipse fitted myofiber. non-geometry column colGeometry, colGeometryUnivariate() like annotGeometryUnivariate() , none colGeometries dataset extra columns. gene expression, logcounts assay used default (use exprs_values argument change assay), though may may best practice. metrics computed large number features, parallel computing supported, BiocParallel, BPPARAM argument. Moran’s commonly used, runMoransI(sfe_tissue, features = hvgs) equivalent runUnivariate(sfe_tissue, type = \"moran\", features = hvgs).","code":"sfe_tissue <- colDataUnivariate(sfe_tissue, type = \"moran\",                                  features = c(\"nCounts\", \"nGenes\"),                                 colGraphName = \"visium\") colFeatureData(sfe_tissue)[c(\"nCounts\", \"nGenes\"),] #> DataFrame with 2 rows and 2 columns #>         moran_Vis5A   K_Vis5A #>           <numeric> <numeric> #> nCounts    0.528705   3.00082 #> nGenes     0.384028   3.88036 # Remember zero.policy = TRUE since there're singletons sfe_tissue <- annotGeometryUnivariate(sfe_tissue, type = \"moran\",                                       features = c(\"area\", \"eccentricity\"),                                        annotGeometryName = \"myofiber_simplified\",                                       annotGraphName = \"myofiber_poly2nb\",                                        zero.policy = TRUE) attr(annotGeometry(sfe_tissue, \"myofiber_simplified\"), \"featureData\")[c(\"area\", \"eccentricity\"),] #> DataFrame with 2 rows and 2 columns #>              moran_Vis5A   K_Vis5A #>                <numeric> <numeric> #> area            0.327888   4.95675 #> eccentricity    0.110938   3.26913 sfe_tissue <- runUnivariate(sfe_tissue, type = \"moran\", features = hvgs,                              colGraphName = \"visium\", BPPARAM = SerialParam()) rowData(sfe_tissue)[head(hvgs),c(\"moran_Vis5A\", \"K_Vis5A\", \"symbol\")] #> DataFrame with 6 rows and 3 columns #>                    moran_Vis5A   K_Vis5A      symbol #>                      <numeric> <numeric> <character> #> ENSMUSG00000029304    0.734937   1.63516        Spp1 #> ENSMUSG00000050708    0.665563   1.81841        Ftl1 #> ENSMUSG00000050335    0.741474   1.68098      Lgals3 #> ENSMUSG00000021939    0.708362   1.86896        Ctsb #> ENSMUSG00000021190    0.659916   1.66838        Lgmn #> ENSMUSG00000018893    0.675840   1.82510          Mb"},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/articles/workshop.html","id":"exercises-2","dir":"Articles","previous_headings":"Part 2: Voyager ESDA > Univariate global","what":"Exercises","title":"Exploratory spatial data analysis with Voyager","text":"Use listSFEMethods() find “name” Geary’s C (Geary 1954). name used type argument runUnivariate(). Compute Geary’s C highly variable genes, show results. Interpretation Geary’s C: value 1 indicates positive spatial autocorrelation, value 1 indicates negative spatial autocorrelation.","code":""},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/articles/workshop.html","id":"further-reading","dir":"Articles","previous_headings":"Part 2: Voyager ESDA > Univariate global","what":"Further reading","title":"Exploratory spatial data analysis with Voyager","text":"Spatial transcriptomics data usually much larger typical geospatial dataset back 1950s Moran’s Geary’s C devised. See (Luo, Griffith, Wu 2019) asymptotic properties Moran’s large datasets normal skewed distributions. negative binomial distribution often used model transcriptomics data due bursts transcription, although Poisson distribution sometimes used instead simplify math. See (Griffith Haining 2006) consideration Poisson distribution spatial analyses. Moran’s exactly Pearson correlation values spatially smoothed values. bounds Moran’s depend spatial neighborhood graph. Usually upper bound around 1, lower bound closer -0.5 -1. See (Jong, Sprenger, Veen 1984) derivation extreme values Moran’s Geary’s C. Spatial autocorrelation decays different length scales different features, correlogram one way find length scales. vignettes use correlograms. Also see vignette Moran’s flipping signs different length scales.","code":""},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/articles/workshop.html","id":"univariate-local","dir":"Articles","previous_headings":"Part 2: Voyager ESDA","what":"Univariate local","title":"Exploratory spatial data analysis with Voyager","text":"Local statistics yield result location rather whole dataset, global statistics may obscure local heterogeneity. See (Fotheringham 2009) interesting discussion relationships global local spatial statistics. Local statistics stored localResults field SFE object, can accessed localResult() localResults() functions SpatialFeatureExperiment package. univariate local methods Voyager listed :","code":"listSFEMethods(variate = \"uni\", scope = \"local\") #>               name                                          description #> 1       localmoran                                      Local Moran's I #> 2  localmoran_perm                  Local Moran's I permutation testing #> 3           localC                                      Local Geary's C #> 4      localC_perm                  Local Geary's C permutation testing #> 5           localG                                      Getis-Ord Gi(*) #> 6      localG_perm             Getis-Ord Gi(*) with permutation testing #> 7             LOSH                     Local spatial heteroscedasticity #> 8          LOSH.mc Local spatial heteroscedasticity permutation testing #> 9          LOSH.cs     Local spatial heteroscedasticity Chi-square test #> 10      moran.plot                                   Moran scatter plot"},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/articles/workshop.html","id":"local-morans-i","dir":"Articles","previous_headings":"Part 2: Voyager ESDA > Univariate local","what":"Local Moran’s I","title":"Exploratory spatial data analysis with Voyager","text":"recap, global Moran’s defined \\[ = \\frac{n}{\\sum_{=1}^n \\sum_{j=1}^n w_{ij}} \\frac{\\sum_{=1}^n \\sum_{j=1}^n w_{ij} (x_i - \\bar{x})(x_j - \\bar{x})}{\\sum_{=1}^n (x_i - \\bar{x})^2}. \\] Local Moran’s (Anselin 1995) defined \\[ I_i = (n-1)\\frac{(x_i - \\bar{x})\\sum_{j=1}^n w_{ij} (x_j - \\bar{x})}{\\sum_{=1}^n (x_i - \\bar{x})^2}. \\] ’s similar global Moran’s , values locations \\(\\) summed ’s normalization sum spatial weights. Local Moran’s used spatial transcriptomics MERINGUE package (Miller et al. 2021). compute local Moran’s gene Myh2. useful plot log normalized Myh2 gene expression context interpret local results:  local spatial results can plotted plotLocalResults(), similar plotSpatialFeature(). divergent palette used Moran’s sensible center 0 (actually expected value Moran’s -1/(n-1) mean unknown, ’s close 0 n typically large spatial -omics).  see myofiber regions higher Myh2 expression also stronger spatial autocorrelation, injury site locally negative spatial autocorrelation. results stored localResults field SFE object, getters setters analogous reducedDims, name local method feature/gene local method run need specified well. interesting see spatial autocorrelation relates gene expression level, much finding variance relates mean expression gene, usually indicates overdispersion compared Poisson scRNA-seq Visium data:  gene, Visium spots higher expression also tend higher local Moran’s , may may apply genes. vertical dashed line marks mean gene expression; note subtraction mean expression global local Moran’s , leading spots close mean local Moran’s close 0. Local spatial analyses often return matrix data frame. plotLocalResult() function default column local spatial method, columns can plotted well. Use localResultAttrs() function see columns present, use attribute argument specify column plot. local spatial methods return p-values location, column name like Pr(z != E(Ii)), test two sided (default, can changed alternative argument runUnivariate() passed relevant underlying function spdep). Negative log p-value computed facilitate visualization (smaller significant p-values plotted higher values), p-value corrected multiple hypothesis testing p.adjustSP() spdep, number tests number neighbors location rather total number locations (-log10p_adj).  plot following plots p-values, divergent palette used show locations significant adjusting multiple testing significant different colors. center divergent palette p = 0.05, brown spots significant dark blue means really significant. “pysal” column shows type neighborhood, whether low value near low values, high value near high values.","code":"sfe_tissue <- runUnivariate(sfe_tissue, type = \"localmoran\", features = \"Myh2\",                             colGraphName = \"visium\", swap_rownames = \"symbol\") plotSpatialFeature(sfe_tissue, features = \"Myh2\", colGeometryName = \"spotPoly\",                    swap_rownames = \"symbol\", image_id = \"lowres\", color = \"black\",                    linewidth = 0.1) plotLocalResult(sfe_tissue, \"localmoran\", features = \"Myh2\",                  colGeometryName = \"spotPoly\", divergent = TRUE,                 diverge_center = 0, image_id = \"lowres\",                  swap_rownames = \"symbol\", color = \"black\",                 linewidth = 0.1) lr <- localResult(sfe_tissue, type = \"localmoran\", feature = \"Myh2\",                    swap_rownames = \"symbol\") head(lr) #>                          Ii          E.Ii     Var.Ii       Z.Ii Pr(z != E(Ii)) #> AAACATTTCCCGGATT 2.12545883 -0.0012237995 0.37891181 3.45488511   5.505274e-04 #> AAACCTAAGCAGCCGG 3.33088903 -0.0038553468 0.59334776 4.32920244   1.496503e-05 #> AAACGAGACGGTTGAT 0.30430735 -0.0009817045 0.15152269 0.78428227   4.328745e-01 #> AAACGGGCGTACGGGT 4.69775712 -0.0063342069 0.97242481 4.77032239   1.839313e-06 #> AAACTCGGTTCGCAAT 0.01991573 -0.0002817611 0.04351933 0.09681804   9.228709e-01 #> AAACTGCTGGCTCCAA 0.55285063 -0.0009817045 0.15152269 1.42278566   1.547983e-01 #>                       mean    median     pysal    -log10p -log10p_adj #> AAACATTTCCCGGATT High-High High-High High-High 3.25922109    2.657161 #> AAACCTAAGCAGCCGG High-High High-High High-High 4.82492235    3.979824 #> AAACGAGACGGTTGAT   Low-Low   Low-Low   Low-Low 0.36363800    0.000000 #> AAACGGGCGTACGGGT High-High High-High High-High 5.73534434    4.890246 #> AAACTCGGTTCGCAAT High-High High-High High-High 0.03485905    0.000000 #> AAACTGCTGGCTCCAA   Low-Low   Low-Low   Low-Low 0.81023381    0.000000 df <- data.frame(myh2 = logcounts(sfe_tissue)[rowData(sfe_tissue)$symbol == \"Myh2\",],                  Ii = localResult(sfe_tissue, \"localmoran\", \"Myh2\",                                    swap_rownames = \"symbol\")[,\"Ii\"]) ggplot(df, aes(myh2, Ii)) + geom_point(alpha = 0.3) +     geom_vline(xintercept = mean(df$myh2), linetype = 2, color = \"gray\") +     geom_hline(yintercept = 0, linetype = 2, color = \"gray\") +     labs(x = \"Myh2 (log counts)\", y = \"localmoran\") localResultAttrs(sfe_tissue, \"localmoran\", \"Myh2\", swap_rownames = \"symbol\") #>  [1] \"Ii\"             \"E.Ii\"           \"Var.Ii\"         \"Z.Ii\"           #>  [5] \"Pr(z != E(Ii))\" \"mean\"           \"median\"         \"pysal\"          #>  [9] \"-log10p\"        \"-log10p_adj\" plotLocalResult(sfe_tissue, \"localmoran\", features = \"Myh2\",                  colGeometryName = \"spotPoly\", attribute = \"-log10p_adj\", divergent = TRUE,                 diverge_center = -log10(0.05), swap_rownames = \"symbol\",                 image_id = \"lowres\", color = \"black\",                 linewidth = 0.1) plotLocalResult(sfe_tissue, \"localmoran\", features = \"Myh2\",                  colGeometryName = \"spotPoly\", attribute = \"pysal\",                  swap_rownames = \"symbol\", image_id = \"lowres\", color = \"black\",                 linewidth = 0.1)"},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/articles/workshop.html","id":"exercises-3","dir":"Articles","previous_headings":"Part 2: Voyager ESDA > Univariate local","what":"Exercises","title":"Exploratory spatial data analysis with Voyager","text":"Compute local spatial heteroscedasticity (LOSH) (J. Keith Ord Getis 2012) Myh2 plot results. sequential palette appropriate. columns returned LOSH? Plot one space. See documentation spdep::LOSH() meanings columns. spatial pattern LOSH compare local Moran genes?","code":""},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/articles/workshop.html","id":"further-reading-1","dir":"Articles","previous_headings":"Part 2: Voyager ESDA > Univariate local","what":"Further reading","title":"Exploratory spatial data analysis with Voyager","text":"Getis-Ord Gi* (J. K. Ord Getis 1995) another commonly used local spatial statistic identifies hotspots (high values clustered together space) coldspots (low values clostered space). vignettes use Getis-Ord Gi*. Moran scatter plot (Anselin 1996) another ESDA tool. Voyager special function plot results moranPlot(). See vignettes examples Moran scatter plot applied spatial transcriptomics. Analogous Moran scatter plot Geary scatter plot (yet implemented Voyager) proposed (Griffith Chun 2022) said better detect local negative spatial autocorrelation. paper also includes considerations Moran’s Geary’s C.","code":""},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/articles/workshop.html","id":"bivariate","dir":"Articles","previous_headings":"Part 2: Voyager ESDA","what":"Bivariate","title":"Exploratory spatial data analysis with Voyager","text":"spatial methods analyze two variables relate. list bivariate global methods can seen : also local bivariate methods:","code":"listSFEMethods(variate = \"bi\", scope = \"global\") #>                  name                                     description #> 1                 lee                       Lee's bivariate statistic #> 2              lee.mc Lee's bivariate static with permutation testing #> 3            lee.test                                    Lee's L test #> 4     cross_variogram                                 Cross variogram #> 5 cross_variogram_map                             Cross variogram map listSFEMethods(variate = \"bi\", scope = \"local\") #>            name                     description #> 1      locallee Local Lee's bivariate statistic #> 2 localmoran_bv       Local bivariate Moran's I"},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/articles/workshop.html","id":"lees-l","dir":"Articles","previous_headings":"Part 2: Voyager ESDA > Bivariate","what":"Lee’s L","title":"Exploratory spatial data analysis with Voyager","text":"Lee’s L (Lee 2001) developed relating Moran’s Pearson correlation, defined \\[ L_{X,Y} = \\frac{n}{\\sum_{=1}^n \\sum_{j=1}^n w_{ij}} \\frac{\\sum_{=1}^n \\left[ \\sum_{j=1}^n w_{ij}  (x_j - \\bar{x}) \\right] \\left[ \\sum_{j=1}^n w_{ij} (y_j - \\bar{y}) \\right]}{\\sqrt{\\sum_{=1}^n (x_i - \\bar{x})^2}\\sqrt{\\sum_{=1}^n (y_i - \\bar{y})^2} }, \\] \\(n\\) number spots locations, \\(\\) \\(j\\) different locations, spots Visium context, \\(x\\) \\(y\\) variables values location, \\(w_{ij}\\) spatial weight, can inversely proportional distance spots indicator whether two spots neighbors, subject various definitions neighborhood. Giotto package implemented something like Lee’s L (Dries et al. 2021). compute Lee’s L top highly variagle genes (HVGs) dataset: bivariate global results can different formats (matrix Lee’s L lists many methods), results stored SFE object. calculateBivariate() function used perform bivariate analyses. Analogous runUnivariate() runBivariate() stores results SFE object, applies local bivariate methods whose results uniform format stored localResults field just like local univariate results. gives spatially informed correlation matrix among genes, can plotted heatmap:  coexpression blocks can seen. Note unlike Pearson correlation, diagonal 1, \\[ L_{X,X} = \\frac{\\sum_i (\\tilde x_i - \\bar x)^2}{\\sum_i (x_i - \\bar x)^2} = \\mathrm{SSS}_X, \\] approximated ratio variance spatially lagged \\(x\\) variance \\(x\\). spatial lag introduces smoothing, spatial lag reduced variance, making diagonal less 1. spatial smoothing scalar (SSS), Moran’s approximately Pearson correlation \\(X\\) spatially lagged \\(X\\) (\\(\\tilde X\\)) multiplied SSS: \\[ \\approx \\mathrm{SSS}_X \\cdot \\rho_{X, \\tilde X} \\] Similarly Lee’s L, shown (Lee 2001), \\[ L_{X, Y} = \\sqrt{\\mathrm{SSS}_X}\\sqrt{\\mathrm{SSS}_Y} \\cdot \\rho_{\\tilde X, \\tilde Y} \\] spatial clustering, variance less reduced spatial lag, leading larger SSS. Hence \\(X\\) \\(Y\\) spatially distributed like salt pepper strongly correlated, Lee’s L low lack spatial autocorrelation leads small SSS. Weighted correlation network analysis (WGCNA) (Langfelder Horvath 2008) time honored method find gene co-expression modules, can take correlation matrix. interesting apply WGCNA Lee’s L matrix identify spatially informed gene co-expression modules.","code":"hvgs <- getTopHVGs(sfe_tissue, fdr.threshold = 0.01) res <- calculateBivariate(sfe_tissue, type = \"lee\", feature1 = hvgs) pal_rng <- getDivergeRange(res) pal <- scico(256, begin = pal_rng[1], end = pal_rng[2], palette = \"vik\") pheatmap(res, color = pal, show_rownames = FALSE,           show_colnames = FALSE, cellwidth = 1, cellheight = 1,          treeheight_col = 0, treeheight_row = 0)"},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/articles/workshop.html","id":"exercises-4","dir":"Articles","previous_headings":"Part 2: Voyager ESDA > Bivariate","what":"Exercises","title":"Exploratory spatial data analysis with Voyager","text":"Local Lee’s L analogous local Moran’s – disaggregated form Lee’s L showing contribution spot global Lee’s L. derived (Lee 2001) global Lee’s L shown. Run local Lee’s L two genes choice. can use myofiber type marker genes Myh7, Myh2, Myh4, Myh1. plot results space. Hint: Use localResultFeatures() find name results stored . interpret results? See vignette bivariate methods Voyager applied dataset, including local Lee’s L bivariate version local Moran’s .","code":""},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/articles/workshop.html","id":"multivariate","dir":"Articles","previous_headings":"Part 2: Voyager ESDA","what":"Multivariate","title":"Exploratory spatial data analysis with Voyager","text":"Spatial transcriptomics data can anywhere hundreds genes whole genome. tedious manually check univariate spatial statistics one gene time. Furthermore, genes often co-regulated, univariate spatial statistics blind co-regulation. Hence multivariate spatial statistics, analyzing multiple genes simultaneously taking spatial information account. Multivariate spatial methods Voyager listed :","code":"listSFEMethods(\"multi\") #>                name                                      description #> 1        multispati                                   MULTISPATI PCA #> 2      localC_multi                     Multivariate local Geary's C #> 3 localC_perm_multi Multivariate local Geary's C permutation testing"},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/articles/workshop.html","id":"non-spatial-pca","dir":"Articles","previous_headings":"Part 2: Voyager ESDA > Multivariate","what":"Non-spatial PCA","title":"Exploratory spatial data analysis with Voyager","text":"First run regular principal component analysis (PCA), compare type spatially informed PCA known MULTISPATI PCA (Stéphane Dray, Saı̈d, Débias 2008). Use elbow plot see variance explained PC:  Plot top gene loadings PC, contribution gene PC:  Plot first 4 PCs space  first PC separates leukocyte infiltrated injury site myofibers, PC2 PC3 tease muscle tendon junctions.","code":"hvgs2 <- getTopHVGs(dec, n = 2000) sfe_tissue <- runPCA(sfe_tissue, ncomponents = 20, subset_row = hvgs2,                      exprs_values = \"logcounts\", scale = TRUE,                      BSPARAM = IrlbaParam()) ElbowPlot(sfe_tissue) plotDimLoadings(sfe_tissue, swap_rownames = \"symbol\") spatialReducedDim(sfe_tissue, \"PCA\", 4, divergent = TRUE, diverge_center = 0,                   image_id = \"lowres\")"},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/articles/workshop.html","id":"multispati-pca","dir":"Articles","previous_headings":"Part 2: Voyager ESDA > Multivariate","what":"MULTISPATI PCA","title":"Exploratory spatial data analysis with Voyager","text":"Spatially informed dimension reduction actually new, dates back least 1985, Wartenberg’s crossover Moran’s PCA (Wartenberg 1985), generalized developed MULTISPATI PCA (Stéphane Dray, Saı̈d, Débias 2008), implemented adespatial package CRAN. short, PCA tries maximize variance explained PC, MULTISPATI maximizes product Moran’s variance explained. Also, eigenvalues PCA non-negative, covariance matrix positive semidefinite, MULTISPATI can give negative eigenvalues, represent negative spatial autocorrelation, can present interesting common positive spatial autocorrelation often masked latter (Griffith 2019). single cell -omics conventions, let \\(X\\) denote gene count matrix whose columns cells Visium spots whose rows genes, \\(n\\) columns. Let \\(W\\) denote row normalized \\(n\\times n\\) adjacency matrix spatial neighborhood graph cells Visium spots, symmetric. MULTISPATI diagonalizes symmetric matrix \\[ H = \\frac 1 {2n} X(W^t+W)X^t \\] However, implementation adespatial general can used multivariate analyses duality diagram paradigm, correspondence analysis; equation simplified just PCA, without introduce duality diagram . compute MULTISPATI PCA, 20 positive 20 negative eigenvalues. plot positive negative eigenvalues. Note eigenvalues variance explained. Instead, product variance explained Moran’s . positive eigenvalues correspond eigenvectors simultaneously explain variance large positive Moran’s . negative eigenvalues correspond eigenvectors simultaneously explain variance negative Moran’s .  positive eigenvalues drop sharply , PC1, none negative eigenvalues seem noteworthy. However, spatial transcriptomics datasets single cell resolution, can negative eigenvalues corresponding PC biologically relevant, see vignette mouse liver data. components mean? component linear combination genes maximize product variance explained Moran’s . second component maximizes product provided ’s orthogonal first component, . loss variance explained usually huge, components can considered axes along spatially coherent groups spots separated much possible according expression highly variable genes, theory, clustering positive MULTISPATI components give spatially coherent clusters. spatial coherence, MULTISPATI might robust outliers.  Plot PCs:  unlike non-spatial PCA, PC4 continues spatially structured.","code":"sfe_tissue <- runMultivariate(sfe_tissue, \"multispati\", colGraphName = \"visium\",                               nfposi = 20, nfnega = 20, subset_row = hvgs2) #> Warning: useNames = NA is deprecated. Instead, specify either useNames = TRUE #> or useNames = TRUE. ElbowPlot(sfe_tissue, nfnega = 20, reduction = \"multispati\") plotDimLoadings(sfe_tissue, dims = 1:4, reduction = \"multispati\",                 swap_rownames = \"symbol\") spatialReducedDim(sfe_tissue, \"multispati\", 4, divergent = TRUE,                    diverge_center = 0, image_id = \"lowres\")"},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/articles/workshop.html","id":"clustering","dir":"Articles","previous_headings":"Part 2: Voyager ESDA > Multivariate > MULTISPATI PCA","what":"Clustering","title":"Exploratory spatial data analysis with Voyager","text":"PCA embeddings often used clustering scRNA-seq data analysis. perform Leiden clustering non-spatial MULTISPATI PCA embeddings. See clustering positive MULTISPATI PCs give spatially coherent clusters Plot clusters space:","code":"set.seed(29) sfe_tissue$clusts_nonspatial <- clusterCells(sfe_tissue, use.dimred = \"PCA\",                                               BLUSPARAM = NNGraphParam(                                                  cluster.fun = \"leiden\",                                                  cluster.args = list(                                                      objective_function = \"modularity\",                                                      resolution_parameter = 1                                                  )                                              )) set.seed(29) sfe_tissue$clusts_multispati <- clusterRows(reducedDim(sfe_tissue, \"multispati\")[,1:20],                                              BLUSPARAM = NNGraphParam(                                                 cluster.fun = \"leiden\",                                                 cluster.args = list(                                                     objective_function = \"modularity\",                                                     resolution_parameter = 1                                                 )                                             )) plotSpatialFeature(sfe_tissue, c(\"clusts_nonspatial\", \"clusts_multispati\"),                     colGeometryName = \"spotPoly\") &      guides(colour = guide_legend(override.aes = list(size=2), ncol = 2))"},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/articles/workshop.html","id":"spatial-autocorrelation-of-principal-components","dir":"Articles","previous_headings":"Part 2: Voyager ESDA > Multivariate > MULTISPATI PCA","what":"Spatial autocorrelation of principal components","title":"Exploratory spatial data analysis with Voyager","text":"compare Moran’s cell embeddings non-spatial MULTISPATI PC. Just like ’s colDataUnivariate() colDataMoransI() colData columns annotGeometryUnivariate() attributes annotation geometries, univariate spatial statistics can computed cell/spot embeddings reduced dimensions, reducedDimUnivariate(), Moran’s , reducedDimMoransI(). arguments functions similar. lower upper bounds Moran’s given spatial neighborhood graph according (Jong, Sprenger, Veen 1984).  lower upper bounds Moran’s plotted horizontal dashed line. non-spatial PCA, Moran’s drops PC1 PC6, Moran’s remains high subsequent MULTISPATI PCs. Given lower bound Moran’s , negative PCs strong negative spatial autocorrelation. However, -interpreted dataset minuscule magnitude negative eigenvalues, means PCs explain little variance.","code":"# non-spatial sfe_tissue <- reducedDimMoransI(sfe_tissue, dimred = \"PCA\", components = 1:20) # spatial sfe_tissue <- reducedDimMoransI(sfe_tissue, dimred = \"multispati\", components = 1:40) df_moran <- tibble(PCA = reducedDimFeatureData(sfe_tissue, \"PCA\")$moran_Vis5A[1:20],                    MULTISPATI_pos =                         reducedDimFeatureData(sfe_tissue, \"multispati\")$moran_Vis5A[1:20],                    MULTISPATI_neg =                         reducedDimFeatureData(sfe_tissue,\"multispati\")$moran_Vis5A[21:40] |>                         rev(),                    index = 1:20) data(\"ditto_colors\") # Takes a while if not using optimized BLAS (mb <- moranBounds(colGraph(sfe_tissue, \"visium\"))) #>       Imin       Imax  #> -0.5762132  1.0021884 df_moran |>      pivot_longer(cols = -index, values_to = \"value\", names_to = \"name\") |>      ggplot(aes(index, value, color = name)) +     geom_line() +     scale_color_manual(values = ditto_colors) +     geom_hline(yintercept = 0, color = \"gray\") +     geom_hline(yintercept = mb, linetype = 2, color = \"gray\") +     scale_y_continuous(breaks = scales::breaks_pretty()) +     scale_x_continuous(breaks = scales::breaks_width(5)) +     labs(y = \"Moran's I\", color = \"Type\", x = \"Component\")"},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/articles/workshop.html","id":"exercises-5","dir":"Articles","previous_headings":"Part 2: Voyager ESDA > Multivariate","what":"Exercises","title":"Exploratory spatial data analysis with Voyager","text":"Thought experiment: suppose perform standard PCA MULTISPATI PCA city, buildings, demographics, city divided pixels, whichever spatial features find relevant life. principal components look like? MULTISPATI PC’s differ standard PC’s?","code":""},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/articles/workshop.html","id":"further-reading-2","dir":"Articles","previous_headings":"Part 2: Voyager ESDA > Multivariate","what":"Further reading","title":"Exploratory spatial data analysis with Voyager","text":"multivariate spatial method Voyager Bioc 3.17 multivariate generalization local Geary’s C (Anselin 2019). See vignette application dataset. Unlike similar EDA packages spatial -omics data, Voyager extensible, can make uniform user interface run spatial methods, just like Tidymodels. See vignette extending Voyager. spatially informed dimension reduction methods designed spatial -omics data, although tend consider positive spatial autocorrelation. example, see (Shang Zhou 2022) (Velten et al. 2022). paper discusses many types multivariate spatial analyses ecology, besides MULTISPATI PCA (S. Dray et al. 2012). MULTISPATI PCA can thought two extremes. One extreme standard PCA, diagonalizes covariance matrix. extreme Moran eigen map (MEM) (Griffith 1996), uses spatial weights matrix, without data matrix. MEM’s made diagonalizing double centered spatial weights matrix. first eigenvector values make largest possible Moran’s given spatial neighborhood graph. second eigenvector also maximizes Moran’s given ’s orthogonal first eigenvector, . eigenvalues Moran’s multiplied constant. last eigenvector negative Moran’s given spatial neighborhood graph. eigenvectors, MEM’s, represent spatial structures different length scales, can selected used covariates regression account spatial autocorrelation, procedure called spatial filtering (Griffith 2000; Griffith Peres-Neto 2006). See vignette adespatial examples ecology.","code":""},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/articles/workshop.html","id":"caveats","dir":"Articles","previous_headings":"Part 2: Voyager ESDA","what":"Caveats","title":"Exploratory spatial data analysis with Voyager","text":"H&E image plotted behind geometries can alter perception colors geometries. 2D data supported present, although principle, sf GEOS support 3D data. workshop demonstrates ESDA single sample. However, studies often produce multiple biological replica case control groups. ESDA results can compared across samples, next Bioc 3.18, computed jointly across samples within treatment group.","code":""},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/articles/workshop.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session info","title":"Exploratory spatial data analysis with Voyager","text":"","code":"sessionInfo() #> R version 4.3.1 (2023-06-16) #> Platform: x86_64-pc-linux-gnu (64-bit) #> Running under: Ubuntu 22.04.2 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 #>  #> locale: #>  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C               #>  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8     #>  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8    #>  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                  #>  [9] LC_ADDRESS=C               LC_TELEPHONE=C             #> [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C        #>  #> time zone: Etc/UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats4    stats     graphics  grDevices utils     datasets  methods   #> [8] base      #>  #> other attached packages: #>  [1] bluster_1.11.3                 BiocSingular_1.17.1            #>  [3] BiocNeighbors_1.19.0           pheatmap_1.0.12                #>  [5] scico_1.4.0                    tidyr_1.3.0                    #>  [7] tibble_3.2.1                   BiocParallel_1.35.3            #>  [9] patchwork_1.1.2                scales_1.2.1                   #> [11] sf_1.0-14                      Matrix_1.6-0                   #> [13] rjson_0.2.21                   scater_1.29.0                  #> [15] ggplot2_3.4.2                  scran_1.29.0                   #> [17] scuttle_1.11.0                 SFEData_1.3.0                  #> [19] Voyager_1.3.0                  SingleCellExperiment_1.23.0    #> [21] SummarizedExperiment_1.31.1    Biobase_2.61.0                 #> [23] GenomicRanges_1.53.1           GenomeInfoDb_1.37.2            #> [25] IRanges_2.35.2                 S4Vectors_0.39.1               #> [27] BiocGenerics_0.47.0            MatrixGenerics_1.13.0          #> [29] matrixStats_1.0.0              SpatialFeatureExperiment_1.3.0 #> [31] BiocStyle_2.29.1               #>  #> loaded via a namespace (and not attached): #>   [1] later_1.3.1                   bitops_1.0-7                  #>   [3] filelock_1.0.2                R.oo_1.25.0                   #>   [5] lifecycle_1.0.3               edgeR_3.43.7                  #>   [7] rprojroot_2.0.3               lattice_0.21-8                #>   [9] magrittr_2.0.3                limma_3.57.6                  #>  [11] sass_0.4.7                    rmarkdown_2.23                #>  [13] jquerylib_0.1.4               yaml_2.3.7                    #>  [15] metapod_1.9.0                 httpuv_1.6.11                 #>  [17] sp_2.0-0                      RColorBrewer_1.1-3            #>  [19] DBI_1.1.3                     zlibbioc_1.47.0               #>  [21] purrr_1.0.1                   R.utils_2.12.2                #>  [23] RCurl_1.98-1.12               rappdirs_0.3.3                #>  [25] GenomeInfoDbData_1.2.10       ggrepel_0.9.3                 #>  [27] irlba_2.3.5.1                 terra_1.7-39                  #>  [29] units_0.8-2                   RSpectra_0.16-1               #>  [31] dqrng_0.3.0                   pkgdown_2.0.7                 #>  [33] DelayedMatrixStats_1.23.0     codetools_0.2-19              #>  [35] DropletUtils_1.21.0           DelayedArray_0.27.9           #>  [37] tidyselect_1.2.0              farver_2.1.1                  #>  [39] ScaledMatrix_1.9.1            viridis_0.6.4                 #>  [41] BiocFileCache_2.9.1           jsonlite_1.8.7                #>  [43] e1071_1.7-13                  ellipsis_0.3.2                #>  [45] systemfonts_1.0.4             tools_4.3.1                   #>  [47] ggnewscale_0.4.9              ragg_1.2.5                    #>  [49] Rcpp_1.0.11                   glue_1.6.2                    #>  [51] gridExtra_2.3                 SparseArray_1.1.10            #>  [53] xfun_0.39                     dplyr_1.1.2                   #>  [55] HDF5Array_1.29.3              withr_2.5.0                   #>  [57] BiocManager_1.30.21.1         fastmap_1.1.1                 #>  [59] boot_1.3-28.1                 rhdf5filters_1.13.5           #>  [61] fansi_1.0.4                   spData_2.3.0                  #>  [63] digest_0.6.33                 rsvd_1.0.5                    #>  [65] R6_2.5.1                      mime_0.12                     #>  [67] textshaping_0.3.6             colorspace_2.1-0              #>  [69] wk_0.7.3                      RSQLite_2.3.1                 #>  [71] R.methodsS3_1.8.2             utf8_1.2.3                    #>  [73] generics_0.1.3                class_7.3-22                  #>  [75] httr_1.4.6                    S4Arrays_1.1.4                #>  [77] spdep_1.2-8                   pkgconfig_2.0.3               #>  [79] gtable_0.3.3                  blob_1.2.4                    #>  [81] XVector_0.41.1                htmltools_0.5.5               #>  [83] bookdown_0.34                 png_0.1-8                     #>  [85] SpatialExperiment_1.11.0      knitr_1.43                    #>  [87] curl_5.0.1                    proxy_0.4-27                  #>  [89] cachem_1.0.8                  rhdf5_2.45.1                  #>  [91] stringr_1.5.0                 BiocVersion_3.18.0            #>  [93] KernSmooth_2.23-22            parallel_4.3.1                #>  [95] vipor_0.4.5                   AnnotationDbi_1.63.2          #>  [97] desc_1.4.2                    s2_1.1.4                      #>  [99] pillar_1.9.0                  grid_4.3.1                    #> [101] vctrs_0.6.3                   promises_1.2.0.1              #> [103] dbplyr_2.3.3                  beachmat_2.17.13              #> [105] xtable_1.8-4                  cluster_2.1.4                 #> [107] beeswarm_0.4.0                evaluate_0.21                 #> [109] magick_2.7.4                  cli_3.6.1                     #> [111] locfit_1.5-9.8                compiler_4.3.1                #> [113] rlang_1.1.1                   crayon_1.5.2                  #> [115] labeling_0.4.2                classInt_0.4-9                #> [117] fs_1.6.3                      ggbeeswarm_0.7.2              #> [119] stringi_1.7.12                viridisLite_0.4.2             #> [121] deldir_1.0-9                  munsell_0.5.0                 #> [123] Biostrings_2.69.2             ExperimentHub_2.9.1           #> [125] sparseMatrixStats_1.13.0      bit64_4.0.5                   #> [127] Rhdf5lib_1.23.0               KEGGREST_1.41.0               #> [129] statmod_1.5.0                 shiny_1.7.4.1                 #> [131] highr_0.10                    interactiveDisplayBase_1.39.0 #> [133] AnnotationHub_3.9.1           igraph_1.5.0.1                #> [135] memoise_2.0.1                 bslib_0.5.0                   #> [137] bit_4.0.5"},{"path":[]},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Lambda Moses. Author, maintainer.","code":""},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Moses L (2023). VoyagerWorkshop: Bioc2023 workshop ESDA Voyager. R package version 1.0.0, https://lambdamoses.github.io/VoyagerWorkshop/.","code":"@Manual{,   title = {VoyagerWorkshop: Bioc2023 workshop for ESDA with Voyager},   author = {Lambda Moses},   year = {2023},   note = {R package version 1.0.0},   url = {https://lambdamoses.github.io/VoyagerWorkshop/}, }"},{"path":[]},{"path":[]},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/index.html","id":"description","dir":"","previous_headings":"Overview","what":"Description","title":"VoyagerWorkshop","text":"Exploratory spatial data analysis (ESDA) can powerful approach understanding single-cell genomics datasets, yet part standard data analysis workflows. particular, geospatial analyses, developed refined decades, yet fully adapted applied spatial single-cell analysis. introduce Voyager platform, systematically brings geospatial ESDA tradition (spatial) -omics, local, bivariate, multivariate spatial methods yet commonly applied spatial -omics, united uniform user interface. Using Voyager, showcase biological insights can derived methods, biologically relevant negative spatial autocorrelation. Underlying Voyager SpatialFeatureExperiment (SFE) data structure, combines Simple Feature SingleCellExperiment AnnData represent operate geometries bundled gene expression data. Voyager comprehensive tutorials demonstrating ESDA built GitHub Actions ensure reproducibility scalability, using data popular commercial technologies. Voyager implemented R/Bioconductor Python/PyPI, features compatibility tests ensure implementations return consistent results. workshop, get hands experiences R implementation SFE Voyager. First, learn create operate SFE objects. Next perform various types ESDA SFE object Voyager, learn spatial statistics behind methods. workshop material points reading methods. can read Voyager preprint.","code":""},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/index.html","id":"pre-requisites","dir":"","previous_headings":"Overview","what":"Pre-requisites","title":"VoyagerWorkshop","text":"understand workshop material, expected : Intermediate knowledge R syntax ggplot2 Familiarity SingleCellExperiment Familiarity statistics linear algebra, including principal component analysis (PCA) workshop material taken documentation websites Voyager SpatialFeatureExperiment. Relevant vignettes linked relevant sections.","code":""},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/index.html","id":"participation","dir":"","previous_headings":"Overview","what":"Participation","title":"VoyagerWorkshop","text":"workshop consists hands demos, exercises, Q&.","code":""},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/index.html","id":"r--bioconductor-packages-used","dir":"","previous_headings":"Overview","what":"R / Bioconductor packages used","title":"VoyagerWorkshop","text":"Voyager SpatialFeatureExperiment SFEData scater scran SingleCellExperiment","code":""},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/index.html","id":"time-outline","dir":"","previous_headings":"Overview","what":"Time outline","title":"VoyagerWorkshop","text":"Total: 90 minutes","code":""},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/index.html","id":"workshop-goals-and-objectives","dir":"","previous_headings":"Overview","what":"Workshop goals and objectives","title":"VoyagerWorkshop","text":"Experience exploratory data analysis spatial information front center Get taste geospatial tradition","code":""},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/index.html","id":"what-you-will-learn","dir":"","previous_headings":"Overview > Workshop goals and objectives","what":"What you will learn","title":"VoyagerWorkshop","text":"Use operate SFE objects Spatial data visualization Geometric operations Create spatial neighborhood graphs Run spatial analyses different fields SFE objects Visualize spatial analysis results Math commonly used ESDA methods","code":""},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/index.html","id":"what-you-will-not-learn","dir":"","previous_headings":"Overview > Workshop goals and objectives","what":"What you will not learn","title":"VoyagerWorkshop","text":"Technologies collect spatial transcriptomics data Data integration across multiple samples Spatial multi-omics","code":""},{"path":"https://lambdamoses.github.io/VoaygerWorkshop/index.html","id":"to-use-the-docker-image","dir":"","previous_headings":"","what":"To use the Docker image","title":"VoyagerWorkshop","text":"workshop can run remotely Bioconductor Workshop Galaxy. Alternatively, can run locally Docker image: running, navigate http://localhost:8787/ log rstudio:yourchosenpassword. required packages appropriate version July 2023 pre-installed Workshop Galaxy Docker image.","code":"docker run -e PASSWORD=<choose_a_password_for_rstudio> -p 8787:8787 ghcr.io/lambdamoses/voyagerworkshop"}]
